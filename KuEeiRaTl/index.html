<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>不予の测试笔记</title>
<meta name="description" content="<font color=#339999 size=3 >小小Tester的学习历程</font>" />
<link rel="shortcut icon" href="https://Shisuiyi.github.io/favicon.ico?v=1639829654113">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://Shisuiyi.github.io/styles/main.css">



  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="ri-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://Shisuiyi.github.io">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://Shisuiyi.github.io/images/avatar.png?v=1639829654113" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">不予の测试笔记</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#git">Git</a></li>
<li><a href="#%E4%B8%80-%E4%BB%80%E4%B9%88%E6%98%AF-git">一、什么是 Git</a></li>
<li><a href="#1-%E6%A6%82%E5%BF%B5">1. 概念</a></li>
<li><a href="#2-githubgiteegitlab-%E7%9A%84%E5%8C%BA%E5%88%AB">2. github,gitee,gitlab 的区别</a></li>
<li><a href="#%E4%BA%8C-git-%E7%9A%84%E4%BD%BF%E7%94%A8">二、Git 的使用</a></li>
<li><a href="#1-%E6%9C%AC%E5%9C%B0%E6%93%8D%E4%BD%9C">1. 本地操作</a>
<ul>
<li><a href="#11-%E5%AE%89%E8%A3%85">1.1 安装</a>
<ul>
<li><a href="#%E5%9C%A8-linux-%E4%B8%8A%E5%AE%89%E8%A3%85">在 Linux 上安装</a></li>
<li><a href="#%E5%9C%A8-macos-%E4%B8%8A%E5%AE%89%E8%A3%85">在 macOS 上安装</a></li>
<li><a href="#%E5%9C%A8-windows-%E4%B8%8A%E5%AE%89%E8%A3%85">在 Windows 上安装</a></li>
</ul>
</li>
<li><a href="#12-%E5%88%9D%E6%AC%A1%E9%85%8D%E7%BD%AE">1.2 初次配置</a></li>
<li><a href="#13-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%93%E5%BA%93">1.3 初始化仓库</a></li>
<li><a href="#14-%E6%B7%BB%E5%8A%A0%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E8%B7%9F%E8%B8%AA">1.4 添加文件进行跟踪</a></li>
<li><a href="#15-%E6%8F%90%E4%BA%A4%E6%96%87%E4%BB%B6%E5%88%B0%E4%BB%93%E5%BA%93">1.5 提交文件到仓库</a></li>
<li><a href="#16-git-%E7%9A%84%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81">1.6 Git 的三种状态</a></li>
<li><a href="#17-%E6%A3%80%E6%9F%A5%E5%BD%93%E5%89%8D%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81">1.7 检查当前文件状态</a></li>
<li><a href="#18-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95">1.8 查看提交记录</a></li>
</ul>
</li>
<li><a href="#2-%E8%BF%9C%E7%A8%8B%E6%93%8D%E4%BD%9C">2. 远程操作</a>
<ul>
<li><a href="#21-%E5%88%9B%E5%BB%BA%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">2.1 创建远程仓库</a></li>
<li><a href="#22-%E6%B7%BB%E5%8A%A0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">2.2 添加远程仓库</a></li>
<li><a href="#23-%E6%8E%A8%E9%80%81%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">2.3 推送到远程仓库</a></li>
<li><a href="#24-%E4%BB%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%AD%E6%8B%89%E5%8F%96">2.4 从远程仓库中拉取</a></li>
<li><a href="#25-%E5%85%8B%E9%9A%86%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">2.5 克隆远程仓库</a></li>
</ul>
</li>
<li><a href="#3-%E5%88%86%E6%94%AF%E6%93%8D%E4%BD%9C">3. 分支操作</a>
<ul>
<li><a href="#31-%E5%88%86%E6%94%AF%E7%AE%80%E4%BB%8B">3.1 分支简介</a></li>
<li><a href="#32-%E5%88%9B%E5%BB%BA%E5%88%86%E6%94%AF">3.2 创建分支</a></li>
<li><a href="#33-%E5%88%87%E6%8D%A2%E5%88%86%E6%94%AF">3.3 切换分支</a></li>
<li><a href="#34-%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF">3.4 合并分支</a></li>
<li><a href="#35-%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81">3.5 解决冲突</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="ri-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.2s">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          标签
        </a>
      
    
      
        <a href="https://Shisuiyi.github.io/about" class="menu" style="animation-delay: 0.6000000000000001s" target="_blank">
          关于
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700">Powered by <a href="https://github.com/shisuiyi" target="_blank">shisuiyi</a></div>
    <a class="rss" href="https://Shisuiyi.github.io/atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">Git</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2021-12-18 / 18 min read
        </div>
        
          <img class="post-feature-image rounded-lg mx-auto my-4" src="https://Shisuiyi.github.io/post-images/KuEeiRaTl.jpg" alt="">
        
        <div class="post-content yue">
          <h2 id="git">Git</h2>
<h2 id="一-什么是-git">一、什么是 Git</h2>
<h2 id="1-概念">1. 概念</h2>
<p>Git（读音为/g ɪt/）是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。 也是 <code>Linus Torvalds</code> 为了帮助管理 Linux 内核开发而开发的一个开源的版本控制软件。</p>
<p>版本控制工具是践行 <code>devops</code> 理念，<code>CI/CD</code> 中的一个环节，是自动化测试工程师不可或缺的一门技术。</p>
<h2 id="2-githubgiteegitlab-的区别">2. github,gitee,gitlab 的区别</h2>
<ul>
<li>GitHub 是一个面向开源及私有软件项目的托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名 GitHub。</li>
<li>Gitee 是开源中国（OSChina）推出的基于 Git 的代码托管服务，是国内的 GitHub。</li>
<li>GitLab 是一个用于代码仓库管理系统的开源项目，使用 Git 作为代码管理工具，并在此基础上搭建起来的 Web 服务。</li>
</ul>
<h2 id="二-git-的使用">二、Git 的使用</h2>
<h2 id="1-本地操作">1. 本地操作</h2>
<h3 id="11-安装">1.1 安装</h3>
<h4 id="在-linux-上安装">在 Linux 上安装</h4>
<p>如果你想在 Linux 上用二进制安装程序来安装基本的 Git 工具，可以使用发行版包含的基础软件包管理工具来安装。 以 Fedora 为例，如果你在使用它，你可以使用 <code>dnf</code>：</p>
<pre><code class="language-console">$ sudo dnf install git-all
</code></pre>
<p>如果你在基于 Debian 的发行版上，如 Ubuntu，请使用 <code>apt</code>：</p>
<pre><code class="language-console">$ sudo apt install git-all
</code></pre>
<p>要了解更多选择，Git 官方网站上有在各种 Unix 发行版的系统上的安装步骤，网址为 <a href="http://testingpai.com/forward?goto=https%3A%2F%2Fgit-scm.com%2Fdownload%2Flinux">https://git-scm.com/download/linux</a>。</p>
<h4 id="在-macos-上安装">在 macOS 上安装</h4>
<p>在 Mac 上安装 Git 有多种方式。 最简单的方法是安装 Xcode Command Line Tools。 Mavericks （10.9） 或更高版本的系统中，在 Terminal 里尝试首次运行 <em>Git</em> 命令即可。</p>
<pre><code class="language-console">$ git --version
</code></pre>
<p>如果没有安装过命令行开发者工具，将会提示你安装。</p>
<h4 id="在-windows-上安装">在 Windows 上安装</h4>
<p>在 Windows 上安装 Git 也有几种安装方法。 官方版本可以在 Git 官方网站下载。 打开 <a href="http://testingpai.com/forward?goto=https%3A%2F%2Fgit-scm.com%2Fdownload%2Fwin">https://git-scm.com/download/win</a>，下载会自动开始。双击下载的安装文件，按照引导程序安装即可。</p>
<h3 id="12-初次配置">1.2 初次配置</h3>
<p>安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。 这一点很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改，在终端运行如下命令：</p>
<pre><code class="language-bash">git config --global user.name &quot;xinlan&quot;
git config --global user.email &quot;xinlan@example.com&quot;
</code></pre>
<p>加了 <code>--global</code> 表示全局设置，且只需要设置一次。</p>
<h3 id="13-初始化仓库">1.3 初始化仓库</h3>
<p>如果你有一个尚未进行版本控制的项目目录，想要用 Git 来控制它，那么首先需要进入该项目目录中。之后执行命令：</p>
<pre><code class="language-console">$ git init
</code></pre>
<p>该命令将创建一个名为 <code>.git</code> 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。请不要修改它。</p>
<h3 id="14-添加文件进行跟踪">1.4 添加文件进行跟踪</h3>
<p>上面的操作，我们仅仅是做了一个初始化的操作，项目里的文件还没有被跟踪。</p>
<p>如果在一个已存在文件的文件夹（而非空文件夹）中进行版本控制，现在应该开始追踪这些文件了。 可以通过 <code>git add</code> 命令来指定所需的文件来进行追踪。</p>
<pre><code class="language-bash">$ git add *.py
$ git add LICENSE
</code></pre>
<h3 id="15-提交文件到仓库">1.5 提交文件到仓库</h3>
<p>要将上一个步骤中追踪的文件提交到仓库，运行命令 <code>git commit</code>。这样会启动文本编辑器来输入提交说明。</p>
<pre><code class="language-bash"># Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
#
# On branch master
#
# Initial commit
#
# Changes to be committed:
#       new file:   LICENSE
#       new file:   test.py
#
~
~
~
~
~
~
~
~
~
~
&lt;sers/men85/Desktop/study/.git/COMMIT_EDITMSG [unix] (21:15 13/09/2021)1,0-1 All
&quot;C:/Users/men85/Desktop/study/.git/COMMIT_EDITMSG&quot; [unix] 12L, 251C
</code></pre>
<p>也可以在 <code>commit</code> 命令后添加 <code>-m</code> 选项，将提交信息与命令放在同一行</p>
<pre><code class="language-bash">git commit -m &quot;init&quot;
</code></pre>
<h3 id="16-git-的三种状态">1.6 Git 的三种状态</h3>
<p>Git 有三种状态，你的文件可能处于其中之一： <strong>已提交（committed）</strong>、<strong>已修改（modified）</strong> 和 <strong>已暂存（staged）</strong>。</p>
<ul>
<li>已修改表示修改了文件，但还没保存到数据库中。</li>
<li>已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li>
<li>已提交表示数据已经安全地保存在本地数据库中。</li>
</ul>
<p>这会让我们的 Git 项目拥有三个阶段：工作区、暂存区以及 Git 目录。</p>
<figure data-type="image" tabindex="1"><img src="https://Shisuiyi.github.io/post-images/1639827635320.png" alt="" loading="lazy"></figure>
<ul>
<li>工作区即是项目的根目录，是你工作的区域，是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</li>
<li>暂存区是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 按照 Git 的术语叫做“索引”，不过一般说法还是叫“暂存区”。</li>
<li>Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据。</li>
</ul>
<p>基本的 Git 工作流程如下：</p>
<ol>
<li>在工作区中修改文件。</li>
<li>将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。<code>git add</code></li>
<li>提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。<code>git commit</code></li>
</ol>
<h3 id="17-检查当前文件状态">1.7 检查当前文件状态</h3>
<p>你工作目录下的每一个文件都不外乎这两种状态：<strong>已跟踪</strong> 或 <strong>未跟踪</strong>。 已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后， 它们的状态可能是未修改，已修改或已放入暂存区。简而言之，已跟踪的文件就是 Git 已经知道的文件。编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。 在工作时，你可以选择性地将这些修改过的文件放入暂存区，然后提交所有已暂存的修改，如此反复。</p>
<figure data-type="image" tabindex="2"><img src="https://Shisuiyi.github.io/post-images/1639827683799.png" alt="" loading="lazy"></figure>
<p>可以用 <code>git status</code> 命令查看哪些文件处于什么状态。如果所有文件没有修改，且都已经提交到本地数据库，也及时工作区，暂存区，Git 仓库一致，你会看到类似这样的输出：</p>
<pre><code class="language-bash">$ git status
On branch master
nothing to commit, working tree clean
</code></pre>
<p>现在，让我们在项目下创建一个新的 <code>README</code> 文件。 如果之前并不存在这个文件，使用 <code>git status</code> 命令，你将看到一个新的未跟踪文件：</p>
<pre><code class="language-python">$ git status
On branch master
Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)
        README

nothing added to commit but untracked files present (use &quot;git add&quot; to track)
</code></pre>
<p>现在我们来修改一个已被跟踪的文件。 如果你修改了一个名为 <code>test.py</code> 的已被跟踪的文件，然后运行 <code>git status</code> 命令，会看到下面内容：</p>
<pre><code class="language-python">$ git status
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)
        modified:   test.py

Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)
        README

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>
<p>我们在练习一下 Git 的工作流程，将增加的文件和修改的内容提交到 Git 仓库。</p>
<pre><code class="language-bash">$ git add .
$ git commit -m &quot;练习&quot;
[master 2852e80] 缁冧範
 2 files changed, 1 insertion(+)
 create mode 100644 README
</code></pre>
<p>当想要跟踪目录下所有的文件时可以运行命令 <code>git add .</code></p>
<h3 id="18-查看提交记录">1.8 查看提交记录</h3>
<p>在提交了若干更新，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 <code>git log</code> 命令。例如在我的带班课件项目中运行 <code>git log</code> 命令时，可以看到下面的输出：</p>
<pre><code class="language-bash">$ git log
commit 304b472cab3fcff5c220bf3e8e91a2e2fa642003 (HEAD -&gt; master, origin/master)
Author: xinlan &lt;117220100@qq.com&gt;
Date:   Thu Aug 26 14:05:00 2021 +0800

    日常

commit 65f23a537366f35bd99047438c40547278294028
Author: xinlan &lt;117220100@qq.com&gt;
Date:   Fri Aug 6 21:18:35 2021 +0800

    haha

commit eca023381f42ce0428ab45c0a8b33621dd2cc6f8
Author: xinlan &lt;117220100@qq.com&gt;
Date:   Sat May 29 19:19:24 2021 +0800

    py38 day43
</code></pre>
<p>不传入任何参数的默认情况下，<code>git log</code> 会按时间先后顺序列出所有的提交，最近的更新排在最上面。<code>git log</code> 命令还有很多参数，用来搜索和显示。</p>
<p>其中一个非常有用的参数是 <code>--pretty</code>。 这个参数可以使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。 比如 <code>oneline</code> 会将每个提交放在一行显示，在浏览大量的提交时非常有用。 另外还有 <code>short</code>，<code>full</code> 和 <code>fuller</code> 选项，它们展示信息的格式基本一致，但是详尽程度不一：</p>
<pre><code class="language-bash">$ git log --pretty=oneline
304b472cab3fcff5c220bf3e8e91a2e2fa642003 (HEAD -&gt; master, origin/master) 日常
65f23a537366f35bd99047438c40547278294028 haha
eca023381f42ce0428ab45c0a8b33621dd2cc6f8 py38 day43
1b174b1486bae0554ff8a79acca55369387480f9 py41 day2
5ae08fa293a9a6bd7eddf8cb365e07cc221f0c07 py38day42
6fe8725de1151455f25e069ad80357edf5c4d6b0 'py38day41'
2effcc5dc6670a23cdbf4049321923b735ae3f16 add 41
</code></pre>
<h2 id="2-远程操作">2. 远程操作</h2>
<h3 id="21-创建远程仓库">2.1 创建远程仓库</h3>
<p>远程仓库是指托管在因特网或其他网络中的你的项目的版本库。</p>
<p>要创建自己的远程仓库，最简单的方法是在 gitee(码云)，或 GitHub 上创建一个远程仓库。这里推荐使用码云，中文且速度快，下面以码云为例。码云地址 <a href="http://testingpai.com/forward?goto=https%3A%2F%2Fgitee.com%2F">https://gitee.com/</a>，注册账号请自理。</p>
<p>注册并登录码云后，点击右上角的加号，选择新建仓库</p>
<figure data-type="image" tabindex="3"><img src="https://Shisuiyi.github.io/post-images/1639827740062.png" alt="" loading="lazy"></figure>
<p>进入新建仓库页面，填写必要选项后，点击创建</p>
<figure data-type="image" tabindex="4"><img src="https://Shisuiyi.github.io/post-images/1639827761624.png" alt="" loading="lazy"></figure>
<p>仓库创建成功后会出现下面的页面，包含仓库的地址和一些帮助信息<br>
<img src="https://Shisuiyi.github.io/post-images/1639827795985.png" alt="" loading="lazy"></p>
<h3 id="22-添加远程仓库">2.2 添加远程仓库</h3>
<p>运行 <code>git remote add &lt;shortname&gt; &lt;url&gt;</code> 添加一个新的远程 Git 仓库，同时指定一个方便使用的简写。运行</p>
<pre><code class="language-bash">$ git remote add origin git@gitee.com:wcflove/study.git
</code></pre>
<p>这会给当前本地仓库添加一个远程仓库，地址为 <code>git@gitee.com:wcflove/study.git</code>，远程仓库地址的简写为 <code>origin</code>(你可以取你想要的名字)。</p>
<p>运行 <code>git remote -v</code> 命令可以查看远程仓库信息，一个本地仓库可以有多个远程仓库。</p>
<pre><code class="language-bash">$ git remote -v
gitee   git@gitee.com:wcflove/study.git (fetch)
gitee   git@gitee.com:wcflove/study.git (push)
</code></pre>
<h3 id="23-推送到远程仓库">2.3 推送到远程仓库</h3>
<p>通过命令 <code>git push &lt;remote&gt; &lt;branch&gt;</code> 可以将你的本地项目推送到远程仓库。当你想要将 <code>master</code> 分支(关于分支我们后面再详细讨论)推送到 <code>origin</code> 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字）， 那么运行这个命令就可以将你所做的备份到服务器：</p>
<pre><code class="language-bash">$ git push origin master
Enumerating objects: 6, done.
Counting objects: 100% (6/6), done.
Delta compression using up to 8 threads
Compressing objects: 100% (4/4), done.
Writing objects: 100% (6/6), 481 bytes | 481.00 KiB/s, done.
Total 6 (delta 0), reused 0 (delta 0), pack-reused 0
remote: Powered by GITEE.COM [GNK-6.1]
To gitee.com:wcflove/study.git
 * [new branch]      master -&gt; master
</code></pre>
<p>注意：这一步操作需要验证你的权限，如果在添加远程仓库时，使用的是 <code>https</code> 协议的地址，那么需要你输入用户名和密码。如果使用的是 <code>ssh</code> 协议地址，那么需要配置 <code>ssh</code> 的公钥(详见码云帮助文档)。</p>
<p>推送成功后刷新你的远程仓库，你会看到刚刚推送上去的文件。</p>
<figure data-type="image" tabindex="5"><img src="https://Shisuiyi.github.io/post-images/1639827821081.png" alt="" loading="lazy"></figure>
<h3 id="24-从远程仓库中拉取">2.4 从远程仓库中拉取</h3>
<p>从远程仓库中获得数据，可以执行：</p>
<pre><code class="language-bash">$ git pull &lt;remote&gt;
</code></pre>
<p>这个命令会访问远程仓库，从中拉取所有你还没有的数据，并自动合并该远程分支到当前分支。</p>
<h3 id="25-克隆远程仓库">2.5 克隆远程仓库</h3>
<p>运行命令 <code>git clone &lt;url&gt;</code> 会将远程仓库下载到当前目录。例如：</p>
<pre><code class="language-bash">git clone git@gitee.com:wcflove/study.git
</code></pre>
<p>这会在当前目录创建 <code>study</code> 文件夹，并在这个目录下初始化一个 <code>.git</code> 文件夹，自动将地址 <code>git@gitee.com:wcflove/study.git</code> 添加为远程仓库并默认以 “origin” 为简写， 自动设置本地 master 分支跟踪克隆的远程仓库的 <code>master</code> 分支，并从远程仓库拉取 master 分支下所有数据放入 <code>.git</code> 文件夹，然后从中读取最新版本的文件的拷贝。</p>
<h2 id="3-分支操作">3. 分支操作</h2>
<h3 id="31-分支简介">3.1 分支简介</h3>
<p>几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。</p>
<p>为了真正理解 Git 处理分支的方式，我们需要回顾一下 Git 是如何保存数据的。Git 保存的不是文件的变化或者差异，而是一系列不同时刻的 <strong>快照</strong> 。在进行提交操作时，Git 会保存一个提交对象（commit object）。该提交对象会包含一个指向暂存内容快照的指针，还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。 首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象， 而由多个分支合并产生的提交对象有多个父对象。</p>
<p><img src="https://Shisuiyi.github.io/post-images/1639827835924.png" alt="" loading="lazy"><br>
Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 <code>master</code>。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 <code>master</code> 分支。 <code>master</code> 分支会在每次提交时自动向前移动。</p>
<figure data-type="image" tabindex="6"><img src="https://Shisuiyi.github.io/post-images/1639827845889.png" alt="" loading="lazy"></figure>
<h3 id="32-创建分支">3.2 创建分支</h3>
<p>创建分支非常简单，它只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用 <code>git branch</code> 命令：</p>
<pre><code class="language-bash">$ git branch testing
</code></pre>
<p>这会在当前所在的提交对象上创建一个指针。</p>
<figure data-type="image" tabindex="7"><img src="https://Shisuiyi.github.io/post-images/1639827857699.png" alt="" loading="lazy"></figure>
<p>Git 中有一个名为 <code>HEAD</code> 的特殊指针，指向当前所在的本地分支（译注：将 <code>HEAD</code> 想象为当前分支的别名）。 在本例中，你仍然在 <code>master</code> 分支上。 因为 <code>git branch</code> 命令仅仅 <strong>创建</strong> 一个新分支，并不会自动切换到新分支中去。</p>
<figure data-type="image" tabindex="8"><img src="https://Shisuiyi.github.io/post-images/1639827867850.png" alt="" loading="lazy"></figure>
<h3 id="33-切换分支">3.3 切换分支</h3>
<p>要切换到一个已存在的分支，你需要使用 <code>git checkout</code> 命令。 我们现在切换到新创建的 <code>testing</code> 分支去：</p>
<pre><code class="language-console">$ git checkout testing
</code></pre>
<p>这样 <code>HEAD</code> 就指向 <code>testing</code> 分支了。</p>
<figure data-type="image" tabindex="9"><img src="https://Shisuiyi.github.io/post-images/1639827877937.png" alt="" loading="lazy"></figure>
<h3 id="34-合并分支">3.4 合并分支</h3>
<p>当我们在 testing 分支上工作并形成了一些列提交后，可以切换回 master 分支，然后运行 <code>git merge</code> 命令：</p>
<pre><code class="language-bash">$ git checkout master
$ git merge testing
</code></pre>
<p>将其合并到 master 分支上。</p>
<h3 id="35-解决冲突">3.5 解决冲突</h3>
<p>有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。</p>
<pre><code class="language-bash">$ git merge testing
Auto-merging test.py
CONFLICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and then commit the result.
</code></pre>
<p>此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 <code>git status</code> 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件：</p>
<pre><code class="language-bash">$ git status
On branch master
You have unmerged paths.
  (fix conflicts and run &quot;git commit&quot;)

Unmerged paths:
  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)

    both modified:      test.py

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>
<p>任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：</p>
<pre><code class="language-bash">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:test.py
print('hello world!')
=======
print(&quot;hello world!&quot;)
&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev:test.py
</code></pre>
<p>这表示 <code>HEAD</code> 所指示的版本（也就是你的 <code>master</code> 分支所在的位置，因为你在运行 merge 命令的时候已经切换到了这个分支）在这个区段的上半部分（<code>=======</code> 的上半部分），而 <code>dev</code> 分支所指示的版本在 <code>=======</code> 的下半部分。 为了解决冲突，你必须选择使用由 <code>=======</code> 分割的两部分中的一个，或者你也可以自行合并这些内容。</p>
<p>例如，你可以通过把这段内容换成下面的样子来解决冲突：</p>
<pre><code class="language-python">print(&quot;hello world!&quot;)
</code></pre>
<p>上述的冲突解决方案仅保留了其中一个分支的修改，并且 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> , <code>=======</code> , 和 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 这些行被完全删除了。 在你解决了所有文件里的冲突之后，对每个文件使用 <code>git add</code> 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。</p>
<p>你可以再次运行 <code>git status</code> 来确认所有的合并冲突都已被解决：</p>
<pre><code class="language-python">$ git status
On branch master
All conflicts fixed but you are still merging.
  (use &quot;git commit&quot; to conclude merge)

Changes to be committed:

    modified:   test.py
</code></pre>
<p>如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入 <code>git commit</code> 来完成合并提交。</p>

        </div>

        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://Shisuiyi.github.io/L09CmH-ph/">
            <span class="flex-auto">Git</span>
          </a>
        


        <div class="flex justify-between py-8">
          

          
            <div class="next-post">
              <a href="https://Shisuiyi.github.io/edNg_Vcbf/">
                <h3 class="post-title">
                  持续集成与jenkins
                  <i class="ri-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '978584b9702b5d850dd5',
    clientSecret: 'b6647706cb7b990e2cd5ca77eccf73943df73a6c',
    repo: 'Shisuiyi.github.io',
    owner: 'shisuiyi',
    admin: ['shisuiyi'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

      </div>
    </div>

    <script src="https://Shisuiyi.github.io/media/prism.js"></script>  
<script>

Prism.highlightAll()
let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
