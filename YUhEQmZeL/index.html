<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>不予の测试笔记</title>
<meta name="description" content="<font color=#339999 size=3 >小小Tester的学习历程</font>" />
<link rel="shortcut icon" href="https://Shisuiyi.github.io/favicon.ico?v=1639399183513">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://Shisuiyi.github.io/styles/main.css">



  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="ri-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://Shisuiyi.github.io">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://Shisuiyi.github.io/images/avatar.png?v=1639399183513" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">不予の测试笔记</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B">一、序列类型</a>
<ul>
<li><a href="#1-%E5%AD%97%E7%AC%A6%E4%B8%B2">1. 字符串</a>
<ul>
<li><a href="#11-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AE%9A%E4%B9%89">1.1 字符串的定义</a>
<ul>
<li><a href="#%E5%AE%9A%E4%B9%89%E7%A9%BA%E5%AD%97%E7%AC%A6%E4%B8%B2">定义空字符串</a></li>
</ul>
</li>
<li><a href="#12-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%B4%A2%E5%BC%95">1.2 字符串的索引</a></li>
<li><a href="#13-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%87%E7%89%87">1.3 字符串的切片</a>
<ul>
<li><a href="#%E6%80%9D%E8%80%83">思考</a></li>
</ul>
</li>
<li><a href="#14-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5">1.4 字符串拼接</a></li>
<li><a href="#15-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">1.5 字符串常用方法</a>
<ul>
<li><a href="#strisalpha">str.isalpha()</a></li>
<li><a href="#strisdigit">str.isdigit()</a></li>
<li><a href="#strislower">str.islower()</a></li>
<li><a href="#strisupper">str.isupper()</a></li>
<li><a href="#strisspace">str.isspace</a></li>
<li><a href="#strupper">str.upper()</a></li>
<li><a href="#strlower">str.lower()</a></li>
<li><a href="#strstripchars">str.strip(chars = &quot; &quot;)</a></li>
<li><a href="#strlstripchars">str.lstrip(chars = &quot; &quot;)</a></li>
<li><a href="#strrstripchars">str.rstrip(chars = &quot; &quot;)</a></li>
<li><a href="#strreplaceoldnewcount-1">str.replace(old,new,count= -1)</a></li>
<li><a href="#strsplitstr-numstringcountstr">str.split(str=&quot;&quot;, num=string.count(str))</a></li>
<li><a href="#strindexsub-startnone-endnone">str.index(sub, start=None, end=None)</a></li>
<li><a href="#strfindsub-startnone-endnone">str.find(sub, start=None, end=None)</a></li>
<li><a href="#strcount-sub-startnone-endnone">str.count( sub, start=None, end=None)</a></li>
</ul>
</li>
<li><a href="#16-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E5%80%BC%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96">1.6 字符串和数值的相互转化</a></li>
<li><a href="#17-%E8%BD%AC%E4%B9%89%E7%AC%A6">1.7 转义符</a></li>
<li><a href="#18-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96">1.8 字符串格式化</a>
<ul>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96"><code>%</code> 字符串格式化</a></li>
<li><a href="#format-%E5%87%BD%E6%95%B0%E6%A0%BC%E5%BC%8F%E5%8C%96"><code>format</code> 函数格式化</a></li>
<li><a href="#%E6%A0%BC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E5%80%BC">格式字符串字面值</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-%E5%88%97%E8%A1%A8">2. 列表</a>
<ul>
<li><a href="#21-%E5%88%97%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89">2.1 列表的定义</a></li>
<li><a href="#22-%E5%88%97%E8%A1%A8%E7%9A%84%E6%8B%BC%E6%8E%A5">2.2 列表的拼接</a></li>
<li><a href="#23-%E5%88%97%E8%A1%A8%E7%9A%84%E7%B4%A2%E5%BC%95%E5%92%8C%E5%88%87%E7%89%87">2.3 列表的索引和切片</a></li>
<li><a href="#24-%E5%88%97%E8%A1%A8%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C">2.4 列表的常用操作</a>
<ul>
<li><a href="#241-%E4%BF%AE%E6%94%B9%E5%85%83%E7%B4%A0">2.4.1 修改元素</a></li>
<li><a href="#242-%E5%A2%9E%E5%8A%A0%E5%85%83%E7%B4%A0">2.4.2 增加元素</a></li>
<li><a href="#243-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0">2.4.3 删除元素</a></li>
</ul>
</li>
<li><a href="#25-%E5%88%97%E8%A1%A8%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95">2.5 列表的其他方法</a></li>
<li><a href="#26-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%88%97%E8%A1%A8%E7%9A%84%E8%BD%AC%E6%8D%A2">2.6 字符串和列表的转换</a></li>
</ul>
</li>
<li><a href="#3-%E5%85%83%E7%BB%84">3. 元组</a>
<ul>
<li><a href="#31-%E5%85%83%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89">3.1 元组的定义</a></li>
<li><a href="#32-%E5%85%83%E7%BB%84%E7%9A%84%E7%B4%A2%E5%BC%95%E5%92%8C%E5%88%87%E7%89%87">3.2 元组的索引和切片</a></li>
<li><a href="#32-%E5%85%83%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C">3.2 元组的常用操作</a></li>
<li><a href="#33-%E5%85%83%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">3.3 元组的常用方法</a></li>
<li><a href="#34-len-%E5%87%BD%E6%95%B0">3.4 len 函数</a></li>
</ul>
</li>
<li><a href="#4-%E5%8F%AF%E5%8F%98%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1">4. 可变与不可变对象</a>
<ul>
<li><a href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1">有哪些可变对象，哪些不可变对象？</a></li>
<li><a href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB">不可变对象和可变对象的区别？</a></li>
</ul>
</li>
<li><a href="#5%E5%8F%AF%E5%93%88%E5%B8%8C%E5%AF%B9%E8%B1%A1">5.可哈希对象</a></li>
<li><a href="#6%E8%B5%8B%E5%80%BC%E4%B8%8E%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D">6.赋值与深浅拷贝</a>
<ul>
<li><a href="#61-%E8%B5%8B%E5%80%BC">6.1 赋值</a>
<ul>
<li><a href="#611-%E5%AE%9E%E9%99%85%E7%9A%84%E4%B8%80%E7%A7%8D%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">6.1.1 实际的一种应用场景</a></li>
<li><a href="#612%E6%8B%B7%E8%B4%9D%E7%9A%84%E8%AF%9E%E7%94%9F">6.1.2拷贝的诞生</a></li>
<li><a href="#613copy-%E6%A8%A1%E5%9D%97">6.1.3copy 模块</a></li>
</ul>
</li>
<li><a href="#62%E6%B5%85%E6%8B%B7%E8%B4%9D">6.2浅拷贝</a>
<ul>
<li><a href="#621%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%90%8E%E7%9A%84%E5%80%BC%E6%98%AF%E7%9B%B8%E5%90%8C%E7%9A%84">6.2.1浅拷贝后的值是相同的</a></li>
<li><a href="#622%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%90%8E%E7%9A%84%E4%BC%9A%E4%BA%A7%E7%94%9F%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%AF%B9%E8%B1%A1">6.2.2浅拷贝后的会产生一个新的对象</a></li>
<li><a href="#623%E4%BF%AE%E6%94%B9%E5%88%97%E8%A1%A8%E5%86%85%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E5%85%83%E7%B4%A0">6.2.3修改列表内的不可变对象元素</a></li>
<li><a href="#624%E4%BF%AE%E6%94%B9%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E7%90%86%E5%9B%BE">6.2.4修改不可变对象的原理图</a></li>
<li><a href="#625%E4%BF%AE%E6%94%B9%E5%88%97%E8%A1%A8%E5%86%85%E7%9A%84%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E5%85%83%E7%B4%A0">6.2.5修改列表内的可变对象元素</a></li>
<li><a href="#626%E4%BF%AE%E6%94%B9%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E7%90%86%E5%9B%BE">6.2.6修改可变对象的原理图</a></li>
<li><a href="#627%E6%80%BB%E7%BB%93">6.2.7总结</a></li>
</ul>
</li>
<li><a href="#63-%E6%B7%B1%E6%8B%B7%E8%B4%9D">6.3 深拷贝</a>
<ul>
<li><a href="#631%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%8E%9F%E7%90%86%E5%9B%BE">6.3.1深拷贝原理图</a></li>
<li><a href="#632%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">6.3.2浅拷贝的多种实现方式</a></li>
<li><a href="#633%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B5%85%E6%8B%B7%E8%B4%9D-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB">6.3.3面试题：浅拷贝、深拷贝的区别</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="ri-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.2s">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          标签
        </a>
      
    
      
        <a href="https://Shisuiyi.github.io/about" class="menu" style="animation-delay: 0.6000000000000001s" target="_blank">
          关于
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700">Powered by <a href="https://github.com/shisuiyi" target="_blank">shisuiyi</a></div>
    <a class="rss" href="https://Shisuiyi.github.io/atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">python 基本数据类型 ·中</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2021-10-10 / 38 min read
        </div>
        
          <img class="post-feature-image rounded-lg mx-auto my-4" src="https://Shisuiyi.github.io/post-images/YUhEQmZeL.jpg" alt="">
        
        <div class="post-content yue">
          <h2 id="一-序列类型">一、序列类型</h2>
<p>序列类型用来表示有序的元素集合。</p>
<h3 id="1-字符串">1. 字符串</h3>
<p>python 中字符串用 str 表示，字符串是使用单引号，双引号，三引号包裹起来的字符的序列，用来表示文本信息。</p>
<h4 id="11-字符串的定义">1.1 字符串的定义</h4>
<pre><code class="language-python">a = 'a'
b = &quot;bc&quot;
c = &quot;&quot;&quot;hello,world&quot;&quot;&quot;
d = '''hello,d'''
e = &quot;&quot;&quot;
    hello,
    world!
    &quot;&quot;&quot;
print('a的类型为：', type(a))    # a的类型为： &lt;class 'str'&gt;
print('b的类型为：', type(b))    # b的类型为： &lt;class 'str'&gt;
print('c的类型为：', type(c))    # c的类型为： &lt;class 'str'&gt;
print('d的类型为：', type(d))    # d的类型为： &lt;class 'str'&gt;
print('e的类型为：', type(e))    # e的类型为： &lt;class 'str'&gt;
</code></pre>
<p>a 的类型为： &lt;class 'str'&gt;<br>
b 的类型为： &lt;class 'str'&gt;<br>
c 的类型为： &lt;class 'str'&gt;<br>
d 的类型为： &lt;class 'str'&gt;<br>
e 的类型为： &lt;class 'str'&gt;<br>
使用单引号和双引号进行字符串定义没有任何区别，当要表示字符串的单引号时用双引号进行定义字符串，反之亦然。</p>
<p>一对单引号或双引号只能创建单行字符串，三引号可以创建多行表示的字符串。三双引号一般用来做多行注释，表示函数，类定义时的说明。</p>
<pre><code class="language-python">print('最近我看了&quot;平凡的世界&quot;')
print(&quot;最近我看了'平凡的世界'&quot;)
</code></pre>
<p>最近我看了&quot;平凡的世界&quot;<br>
最近我看了'平凡的世界'</p>
<h5 id="定义空字符串">定义空字符串</h5>
<pre><code class="language-python">a = ''
print(a)
</code></pre>
<h4 id="12-字符串的索引">1.2 字符串的索引</h4>
<p>任何序列类型中的元素都有 <code>索引</code> 用来表示它在序列中的位置。</p>
<p>字符串是字符的序列表示，单个字符在字符串中的位置使用 <code>索引</code> 来表示，也叫下标。</p>
<p>索引使用整数来表示。<br>
<img src="https://Shisuiyi.github.io/post-images/1633842875466.png" alt="" loading="lazy"></p>
<p>通过 <code>索引</code> 可以获取字符串中的单个字符</p>
<p>语法如下：</p>
<pre><code class="language-python">str[index]
s = 'hello world!'
print(s[0])
print(s[-1])
</code></pre>
<p>h<br>
!<br>
注意字符串索引从 0 开始</p>
<h4 id="13-字符串的切片">1.3 字符串的切片</h4>
<p>获取序列中的子序列叫切片。</p>
<p>字符串的切片就是获取字符串的子串。</p>
<p>字符串切片的语法如下：</p>
<pre><code class="language-python">str[start:end:step]
</code></pre>
<p><code>start</code> 表示起始索引，<code>end</code> 表示结束索引，<code>step</code> 表示步长。</p>
<p><code>str[m:n:t]</code> 表示从字符串索引为 <code>m</code> 到 <code>n</code> 之间不包含 <code>n</code> 每隔 <code>t</code> 个字符进行切片。</p>
<p>当 <code>step</code> 为 1 的时候可以省略。</p>
<p>特别的，当 <code>step</code> 为负数时，表示反向切片。</p>
<pre><code class="language-python">s = '0123456789'
print(s[1:5])  # 包头不包尾
</code></pre>
<p>1234</p>
<pre><code class="language-python">print(s[:5])  # 从头开始切可以省略start
</code></pre>
<p>01234</p>
<pre><code class="language-python">print(s[1:])  # 切到末尾省略end
</code></pre>
<p>123456789</p>
<pre><code class="language-python">print(s[1::2]) # 步长为2进行切片
</code></pre>
<p>13579</p>
<pre><code class="language-python">print(s[1::-2]) # 步长为负数反向切片
</code></pre>
<p>1</p>
<h5 id="思考">思考</h5>
<p>获取一个字符串的逆串，例如 <code>'abc'</code> 的逆串是 <code>'cba'</code>。</p>
<pre><code class="language-python">w=&quot;abc&quot;
print(w[::-1])
</code></pre>
<h4 id="14-字符串拼接">1.4 字符串拼接</h4>
<p>python 中可以通过 <code>+</code> 拼接两个字符串</p>
<pre><code class="language-python">a = 'hello'
b = ' '
c = 'world!'
print(a+b+c)
</code></pre>
<p>hello world!<br>
字符串和整数进行乘法运算表示重复拼接这个字符串</p>
<pre><code class="language-python">print('*' * 10)
</code></pre>
<hr>
<h4 id="15-字符串常用方法">1.5 字符串常用方法</h4>
<p>通过内建函数 <code>dir</code> 可以返回传入其中的对象的所有方法名列表。</p>
<pre><code class="language-python">print(dir(str))
</code></pre>
<p>['<strong>add</strong>', '<strong>class</strong>', '<strong>contains</strong>', '<strong>delattr</strong>', '<strong>dir</strong>', '<strong>doc</strong>', '<strong>eq</strong>', '<strong>format</strong>', '<strong>ge</strong>', '<strong>getattribute</strong>', '<strong>getitem</strong>', '<strong>getnewargs</strong>', '<strong>gt</strong>', '<strong>hash</strong>', '<strong>init</strong>', '<strong>init_subclass</strong>', '<strong>iter</strong>', '<strong>le</strong>', '<strong>len</strong>', '<strong>lt</strong>', '<strong>mod</strong>', '<strong>mul</strong>', '<strong>ne</strong>', '<strong>new</strong>', '<strong>reduce</strong>', '<strong>reduce_ex</strong>', '<strong>repr</strong>', '<strong>rmod</strong>', '<strong>rmul</strong>', '<strong>setattr</strong>', '<strong>sizeof</strong>', '<strong>str</strong>', '<strong>subclasshook</strong>', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']<br>
通过内建函数 help 可以返回传入函数的帮助信息。</p>
<pre><code class="language-python">help('abc'.replace)
</code></pre>
<p>Help on built-in function replace:</p>
<p>replace(old, new, count=-1, /) method of builtins.str instance<br>
Return a copy with all occurrences of substring old replaced by new.</p>
<p>count<br>
Maximum number of occurrences to replace.<br>
-1 (the default value) means replace all occurrences.</p>
<p>If the optional argument count is given, only the first count occurrences are<br>
replaced.<br>
<a href="https://docs.python.org/3/library/stdtypes.html?utm_source=testingpai.com#string-methods">官方文档地址</a></p>
<hr>
<h5 id="strisalpha">str.isalpha()</h5>
<p>作用：检查字符串是否只由字母组成 。如果字符串中的所有字符都是字母，并且至少有一个字符，返回 <code>True</code> ，否则返回 <code>False</code></p>
<pre><code class="language-python">str = &quot;abc&quot;
print(str.isalpha())
</code></pre>
<p>执行结果:</p>
<p>true</p>
<hr>
<h5 id="strisdigit">str.isdigit()</h5>
<p>作用：检查字符串是否只由数字组成。如果序列中所有字节都是 ASCII 十进制数码并且序列非空则返回 <code>True</code> ，否则返回 <code>False</code> 。</p>
<pre><code class="language-python">str = &quot;123134123&quot;
print(str.isdigit())
</code></pre>
<p>执行结果</p>
<p>true</p>
<hr>
<h5 id="strislower">str.islower()</h5>
<p>作用：检查字符串是否全部是小写字母。 如果序列中至少有一个小写的 ASCII 字符并且没有大写的 ASCII 字符则返回 <code>True</code> ，否则返回 <code>False</code> 。</p>
<pre><code class="language-python">str ='hello world'
print(str.islower())
</code></pre>
<p>执行结果</p>
<p>true</p>
<hr>
<h5 id="strisupper">str.isupper()</h5>
<p>作用：检查字符串是否全部是大写字母。如果序列中至少有一个大写字母 ASCII 字符并且没有小写 ASCII 字符则返回 <code>True</code> ，否则返回 <code>False</code> 。</p>
<pre><code class="language-python">str ='HELLO WORLD'
print(str.isupper())
</code></pre>
<p>执行结果</p>
<p>true</p>
<hr>
<h5 id="strisspace">str.isspace</h5>
<p>作用：检查字符串只含有空白符。如果序列中所有字节都是 ASCII 空白符并且序列非空则返回 <code>True</code> ，否则返回 <code>False</code> 。 ASCII 空白符就是字节值包含在序列 <code>b' \t\n\r\x0b\f'</code> (空格, 制表, 换行, 回车, 垂直制表, 进纸) 中的字符。</p>
<pre><code class="language-python">str ='\t\n\r\x0b\f'
print(str.isspace())
</code></pre>
<p>执行结果</p>
<p>true</p>
<hr>
<h5 id="strupper">str.upper()</h5>
<p>作用：将字符串都变成大写字母</p>
<h5 id="strlower">str.lower()</h5>
<p>作用：将字符串都变成小写字母</p>
<pre><code class="language-python">str = &quot;hello world !!! hhh&quot;

print(str.upper())
print(str.lower())
</code></pre>
<p>执行结果</p>
<p>HELLO WORLD !!! HHH<br>
hello world !!! hhh</p>
<hr>
<h5 id="strstripchars">str.strip(chars = &quot; &quot;)</h5>
<p>作用：移除字符串头尾指定的字符序列chars，默认为空格</p>
<h5 id="strlstripchars">str.lstrip(chars = &quot; &quot;)</h5>
<p>作用：移除字符串头部指定的字符序列chars，默认为空格</p>
<h5 id="strrstripchars">str.rstrip(chars = &quot; &quot;)</h5>
<p>作用：移除字符串尾部指定的字符序列chars，默认为空格</p>
<pre><code class="language-python">str = &quot;   hello  every  &quot;

print(&quot;1&quot;, str.strip(), &quot;1&quot;)
print(str.lstrip(), &quot;1&quot;)
print(&quot;1&quot;, str.rstrip())

str = &quot;!!! cool !!!&quot;

print(str.strip(&quot;!&quot;))
</code></pre>
<p>执行结果</p>
<p>1 hello  every 1<br>
hello  every   1<br>
1    hello  every<br>
cool</p>
<hr>
<h5 id="strreplaceoldnewcount-1">str.replace(old,new,count= -1)</h5>
<p>作用：把字符串中的 old（旧字符串） 替换成 new(新字符串)，count代表最多替换多少次，默认-1代表全部替换</p>
<pre><code class="language-python">str = &quot;hello world !!! hhh&quot;

print(str.replace(&quot; &quot;, &quot;-&quot;))
print(str.replace(&quot; &quot;, &quot;-&quot;, 1))
</code></pre>
<p>执行结果</p>
<p>hello-world-!!!-hhh<br>
hello-world !!! hhh</p>
<hr>
<h5 id="strsplitstr-numstringcountstr">str.split(str=&quot;&quot;, num=string.count(str))</h5>
<p>作用：将字符串按照str分割成列表，如果参数 num 有指定值，则分隔 num+1 个子字符串</p>
<pre><code class="language-python">str = &quot;hello world !!! hhh&quot;

print(str.split(&quot; &quot;))
print(str.split(&quot; &quot;, 1))
</code></pre>
<p>执行结果</p>
<p>['hello', 'world', '!!!', 'hhh']<br>
['hello', 'world !!! hhh']</p>
<hr>
<h5 id="strindexsub-startnone-endnone">str.index(sub, start=None, end=None)</h5>
<p>作用：查看sub是否在字符串中，在的话返回索引，且只返回第一次匹配到的索引；若找不到则报错；可以指定统计的范围，[start,end) 左闭区间右开区间</p>
<pre><code class="language-python">str = &quot;helloworldhhh&quot;
print(str.index(&quot;h&quot;))
print(str.index(&quot;hhh&quot;))
# print(str.index(&quot;test&quot;)) 直接报语法错误：ValueError: substring not found
</code></pre>
<p>执行结果</p>
<p>0<br>
10</p>
<hr>
<h5 id="strfindsub-startnone-endnone">str.find(sub, start=None, end=None)</h5>
<p>作用：和index()一样，只是找不到不会报错，而是返回-1</p>
<pre><code class="language-python">str = &quot;helloworldhhh&quot;
print(str.find(&quot;h&quot;))
print(str.find(&quot;hhh&quot;))
print(str.find(&quot;test&quot;))
</code></pre>
<p>执行结果</p>
<p>0<br>
10<br>
-1</p>
<hr>
<h5 id="strcount-sub-startnone-endnone">str.count( sub, start=None, end=None)</h5>
<p>作用：统计子字符串的数量；可以指定统计的范围，[start,end) 左闭区间右开区间</p>
<pre><code class="language-python">str = &quot;hello world !!! hhh&quot;

print(str.count(&quot; &quot;))
print(str.count(&quot; &quot;, 5, 10))
</code></pre>
<p>执行结果</p>
<p>3<br>
1</p>
<hr>
<h4 id="16-字符串和数值的相互转化">1.6 字符串和数值的相互转化</h4>
<p><code>1</code> 和 <code>'1'</code> 不同，<code>1.2</code> 和 <code>'1.2'</code> 也不相同，但是它们可以相互转化</p>
<pre><code class="language-python"># 整数和字符串之间的转化
int('1')
</code></pre>
<p>1</p>
<pre><code class="language-python">str(1)
</code></pre>
<p>'1'</p>
<pre><code class="language-python"># 浮点数和字符串之间的转化
float('1.2')
</code></pre>
<p>1.2</p>
<pre><code class="language-python">str(1.2)
</code></pre>
<p>'1.2'</p>
<pre><code class="language-python"># 尝试 int('1.2')看看结果会是什么
int('1.2')
</code></pre>
<h4 id="17-转义符">1.7 转义符</h4>
<p>在需要在字符中使用特殊字符时，python 用反斜杠 <code>\</code> 转义字符。常用转义字符如下表：</p>
<table>
<thead>
<tr>
<th>(在行尾时)</th>
<th>续行符</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\\</code></td>
<td>反斜杠符号</td>
</tr>
<tr>
<td><code>\'</code></td>
<td>单引号</td>
</tr>
<tr>
<td><code>\&quot;</code></td>
<td>双引号</td>
</tr>
<tr>
<td>\a</td>
<td>响铃</td>
</tr>
<tr>
<td>\n</td>
<td>换行</td>
</tr>
<tr>
<td>\t</td>
<td>横向制表符</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>\f</td>
<td>换页</td>
</tr>
</tbody>
</table>
<pre><code class="language-python">print('窗前明月光，\n疑是地上霜。')  # 输出换行
</code></pre>
<p>窗前明月光，<br>
疑是地上霜。</p>
<pre><code class="language-python">print('对\\错')   # 输出反斜杠本身
</code></pre>
<p>对\错</p>
<pre><code class="language-python">print('\'')      # 输出单引号本身
</code></pre>
<h4 id="18-字符串格式化">1.8 字符串格式化</h4>
<p>在实际工作中经常需要动态输出字符。</p>
<p>例如，我们通过程序计算计算机的内存利用率，然后输出</p>
<p>10:15 计算机的内存利用率为30%</p>
<p>其中下划线内容会动态调整，需要根据程序执行结果进行填充，最终形成上述格式的字符串输出。</p>
<p>python 支持两种形式的字符串格式化</p>
<h5 id="字符串格式化"><code>%</code> 字符串格式化</h5>
<pre><code class="language-python">%[(name)][flags][width][.precision]typecode
</code></pre>
<ul>
<li>
<p>(name)<code>可选，用于选择指定的</code>key</p>
</li>
<li>
<p><code>flags</code> 可选，可供选择的值有，注意只有在和数值类型的 <code>typecode</code> 配合才起作用</p>
<ul>
<li><code>+</code>, 右对齐，正数前加正号，负数前加负号</li>
<li><code>-</code>, 左对齐，正数前无符号，负数前加负号</li>
<li><code>空格</code>, 右对齐，正数前加空格，负数前加负号</li>
<li><code>0</code>, 右对齐，正数前无符号，负数前加负号；用 <code>0</code> 填充空白处</li>
</ul>
</li>
<li>
<p><code>width</code>，可选字符串输出宽度</p>
</li>
<li>
<p><code>.precision</code> 可选，小数点后保留位数，注意只有在和数值类型的 <code>typecode</code> 配合才起作用</p>
</li>
<li>
<p><code>typecode</code> 必选必选</p>
<ul>
<li><code>s</code>，获取传入对象的字符串形式，并将其格式化到指定位置</li>
<li><code>r</code>，获取传入对象的 <code>__repr__</code> 方法的返回值，并将其格式化到指定位置</li>
<li><code>c</code>，整数：将数字转换成其 unicode 对应的值，10 进制范围为 0 &lt;= i &lt;= 1114111（py27 则只支持 0-255）；字符：将字符添加到指定位置</li>
<li><code>o</code>，将整数转换成 八 进制表示，并将其格式化到指定位置</li>
<li><code>x</code>，将整数转换成十六进制表示，并将其格式化到指定位置</li>
<li><code>d</code>，将整数、浮点数转换成 十 进制表示，并将其格式化到指定位置</li>
<li><code>e</code>，将整数、浮点数转换成科学计数法，并将其格式化到指定位置（小写 e）</li>
<li><code>E</code>，将整数、浮点数转换成科学计数法，并将其格式化到指定位置（大写 E）</li>
<li><code>f</code>， 将整数、浮点数转换成浮点数表示，并将其格式化到指定位置（默认保留小数点后 6 位）</li>
<li><code>F</code>，同上</li>
<li><code>g</code>，自动调整将整数、浮点数转换成 浮点型或科学计数法表示（超过 6 位数用科学计数法），并将其格式化到指定位置（如果是科学计数则是 e；）`</li>
<li><code>G</code>，自动调整将整数、浮点数转换成 浮点型或科学计数法表示（超过 6 位数用科学计数法），并将其格式化到指定位置（如果是科学计数则是 E；）`</li>
<li><em>%，当字符串中存在格式化标志时，需要用 %% 表示一个百分号</em></li>
</ul>
</li>
</ul>
<pre><code class="language-python">res = '%s计算机的内存利用率为%s%%' % ('11:15', 75)
print(res)
# '%s'作为槽位和 % 号后提供的值按顺序一一对应
</code></pre>
<p>11:15 计算机的内存利用率为 75%</p>
<pre><code class="language-python">res = '%(time)s计算机的内存利用率为%(percent)s%%' % {'time':'11:15', 'percent': 75}
# % 后是字典时，可以通过name指定key对应的值
print(res)
</code></pre>
<p>11:15 计算机的内存利用率为 75%</p>
<pre><code class="language-python"># 输出两位数的月份，例如01，02
res = '%02d' % 8
print(res)
</code></pre>
<p>08</p>
<pre><code class="language-python"># 保留2为小数
res = '%(time)s计算机的内存利用率为%(percent).2f%%' % {'time':'11:15', 'percent': 75.123}
print(res)
</code></pre>
<p>11:15 计算机的内存利用率为 75.12%</p>
<pre><code class="language-python">print('字符串%(key)s,十进制%(key)d,科学计数%(key)e,八进制%(key)o,16进制%(key)x,unicode字符%(key)c' % {'key': 65})
</code></pre>
<p>字符串 65，十进制 65，科学计数 6.500000e+01，八进制 101,16 进制 41,unicode 字符 A</p>
<h5 id="format-函数格式化"><code>format</code> 函数格式化</h5>
<p>模板字符串也是字符串所以用'  '表示，格式化调用format()方法用点方法----如<br>
'{}计算机的内存利用率为{}%'.format('11:15', 75)</p>
<p><code>%</code> 的字符串格式化继承自 C 语言，python 中给字符串对象提供了一个 <code>format</code> 函数进行字符串格式化，且功能更强大，并且大力推荐，所以我们要首选使用。</p>
<p>基本语法是：</p>
<pre><code>&lt;模板字符串&gt;.format(&lt;逗号分隔的参数&gt;)
</code></pre>
<p>在模板字符串中使用 <code>{}</code> 代替以前的 <code>%</code> 作为槽位</p>
<pre><code class="language-python">'{}计算机的内存利用率为{}%'.format('11:15', 75)
</code></pre>
<p>'11:15 计算机的内存利用率为 75%'<br>
当 format 中的参数使用位置参数提供时，<code>{}</code> 中可以填写参数的整数索引和参数一一对应</p>
<pre><code class="language-python">'{0}计算机的内存利用率为{1}%'.format('11:15', 75)
</code></pre>
<p>'11:15 计算机的内存利用率为 75%'<br>
当 format 中的参数使用关键字参数提供时，{}中可以填写参数名和参数一一对应</p>
<pre><code class="language-python">'{time}计算机的内存利用率为{percent}%'.format(time='11:15', percent=75)
</code></pre>
<p>'11:15 计算机的内存利用率为 75%'<br>
<code>{}</code> 中除了可以写参数索引外，还可以填写控制信息来实现更多的格式化功能，语法如下</p>
<pre><code class="language-python">{&lt;参数序号&gt;:&lt;格式控制标记&gt;}
其中格式控制标记格式如下
[fill][align][sign][#][0][width][,][.precision][type]
</code></pre>
<ul>
<li>
<p>fill 【可选】空白处填充的字符</p>
</li>
<li>
<p>align 【可选】对齐方式（需配合 width 使用）</p>
</li>
<li>
<ul>
<li>&lt;，内容左对齐</li>
</ul>
</li>
<li>
<p>&gt;，内容右对齐(默认)</p>
</li>
<li>
<p>＝，内容右对齐，将符号放置在填充字符的左侧，且只对数字类型有效。 即使：符号 + 填充物 + 数字</p>
</li>
<li>
<p>^，内容居中</p>
</li>
<li>
<p>sign 【可选】有无符号数字</p>
<ul>
<li>+，正号加正，负号加负；</li>
<li>-，正号不变，负号加负；</li>
<li>空格 ，正号空格，负号加负；</li>
</ul>
</li>
<li>
<p>#</p>
<pre><code>【可选】对于二进制、八进制、十六进制，如果加上#，会显示 0b/0o/0x，否则不显示
</code></pre>
</li>
<li>
<p>， 【可选】为数字添加分隔符，如：1,000,000</p>
</li>
<li>
<p>width 【可选】格式化位所占宽度</p>
</li>
<li>
<p>.precision 【可选】小数位保留精度</p>
</li>
<li>
<p>type 【可选】格式化类型</p>
<ul>
<li>传入” 字符串类型 “的参数
<ul>
<li>s，格式化字符串类型数据</li>
<li>空白，未指定类型，则默认是 None，同 s</li>
</ul>
</li>
<li>传入“ 整数类型 ”的参数
<ul>
<li>b，将 10 进制整数自动转换成 2 进制表示然后格式化</li>
<li>c，将 10 进制整数自动转换为其对应的 unicode 字符</li>
<li>d，十进制整数</li>
<li>o，将 10 进制整数自动转换成 8 进制表示然后格式化；</li>
<li>x，将 10 进制整数自动转换成 16 进制表示然后格式化（小写 x）</li>
<li>X，将 10 进制整数自动转换成 16 进制表示然后格式化（大写 X）</li>
</ul>
</li>
<li>传入“ 浮点型或小数类型 ”的参数
<ul>
<li>e， 转换为科学计数法（小写 e）表示，然后格式化；</li>
<li>E， 转换为科学计数法（大写 E）表示，然后格式化;</li>
<li>f ， 转换为浮点型（默认小数点后保留 6 位）表示，然后格式化；</li>
<li>F， 转换为浮点型（默认小数点后保留 6 位）表示，然后格式化；</li>
<li>g， 自动在 e 和 f 中切换</li>
<li>G， 自动在 E 和 F 中切换</li>
<li>%，显示百分比（默认显示小数点后 6 位）</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-python"># 输出两位数的月份，例如01，02
res = '{:0&gt;2}'.format(8) 
print(res)
</code></pre>
<p>08</p>
<pre><code class="language-python"># 保留2为小数
res = '{time}计算机的内存利用率为{percent:.2%}'.format(time='11:15', percent=0.75123)
print(res)
</code></pre>
<p>11:15 计算机的内存利用率为 75.12%</p>
<pre><code class="language-python">print('字符串{key},十进制{key:d},科学计数{key:e},八进制{key:o},16进制{key:x},unicode字符{key:c}'.format(key=65))
</code></pre>
<p>字符串 65，十进制 65，科学计数 6.500000e+01，八进制 101,16 进制 41,unicode 字符 A</p>
<h5 id="格式字符串字面值">格式字符串字面值</h5>
<p>3.6 新版功能：</p>
<p>格式字符串字面值或称为 <code>f-string</code> 是标注了 'f' 或 'F' 前缀的字符串字面值。这种字符串可包含替换字段，即以 {} 标注的表达式。</p>
<p>基本语法是：</p>
<pre><code>literal_char{expression[:format_spec]}
</code></pre>
<ul>
<li><code>literal_char</code> 普通字符</li>
<li><code>expression</code> 表达式，变量或函数。。</li>
<li><code>format_spec</code> 格式字符串，规则同上面的 format 字符串</li>
</ul>
<p>直接在 f 字符串的花括号内写上变量名，解释器会自动将变量的值的字符串形式替换</p>
<pre><code class="language-python">item = '11:15'
percent = 75
f'{time}计算机的内存利用率为{percent}%'
'11:15计算机的内存利用率为75%'
</code></pre>
<p>带格式的 f 字符串</p>
<pre><code class="language-python"># 输出两位数的月份，例如01，02
month = 8
res = f'{month:0&gt;2}'
print(res)
</code></pre>
<p>08</p>
<pre><code class="language-python"># 保留2为小数
time = '11:15'
percent = 0.75123
res = f'{time}计算机的内存利用率为{percent:.2%}'
print(res)

</code></pre>
<p>11:15计算机的内存利用率为75.12%</p>
<pre><code class="language-python">key = 65
print(f'字符串{key},十进制{key:d},科学计数{key:e},八进制{key:#o},16进制{key:x},unicode字符{key:c}')
</code></pre>
<p>字符串65,十进制65,科学计数6.500000e+01,八进制0o101,16进制41,unicode字符A</p>
<p>包含运算和函数的 f 字符串</p>
<pre><code class="language-python">num = -1
print(f'{num+1=}')
</code></pre>
<pre><code class="language-python">num+1=0
</code></pre>
<pre><code class="language-python">print(f'{abs(num)=}')
</code></pre>
<pre><code class="language-bash">abs(num)=1
</code></pre>
<pre><code class="language-python">s = 'abcd'
print(f'{s[:python :-1]=}')
</code></pre>
<pre><code class="language-python">s[::-1]='dcba'
</code></pre>
<h3 id="2-列表">2. 列表</h3>
<p>python 中列表(list)用来表示任意元素的序列，元素可以是任意数据类型，序列中的元素可以增，删，改。</p>
<h4 id="21-列表的定义">2.1 列表的定义</h4>
<p>列表由一对中括号进行定义，元素与元素直接使用逗号隔开。</p>
<pre><code class="language-python">a = []                      # 空列表
b = [&quot;a&quot;, &quot;b&quot;, &quot;cde&quot;]       # 字符串列表项
c = [1, &quot;b&quot;, &quot;c&quot;]           # 数字列表项  
d = [1, &quot;b&quot;, []]            # 列表列表项
e = [1, &quot;b&quot;, [2, &quot;c&quot;]]      # 列表作为列表的元素叫做列表的嵌套


print('a的类型为：', type(a))    # a的类型为： &lt;class 'list'&gt;
print('b的类型为：', type(b))    # b的类型为： &lt;class 'list'&gt;
print('c的类型为：', type(c))    # c的类型为： &lt;class 'list'&gt;
print('d的类型为：', type(d))    # d的类型为： &lt;class 'list'&gt;
print('e的类型为：', type(e))    # e的类型为： &lt;class 'list'&gt;
</code></pre>
<p>a 的类型为： &lt;class 'list'&gt;<br>
b 的类型为： &lt;class 'list'&gt;<br>
c 的类型为： &lt;class 'list'&gt;<br>
d 的类型为： &lt;class 'list'&gt;<br>
e 的类型为： &lt;class 'list'&gt;</p>
<h4 id="22-列表的拼接">2.2 列表的拼接</h4>
<p>像字符串一样，列表之间可以进行加法运算实现列表的拼接，列表可以和整数进行乘法运算实现列表的重复。</p>
<pre><code class="language-python">[1,2,3] +  [4,5,6]
</code></pre>
<p>[1, 2, 3, 4, 5, 6]</p>
<pre><code class="language-python">[1,2,3] * 3
</code></pre>
<p>[1, 2, 3, 1, 2, 3, 1, 2, 3]</p>
<h4 id="23-列表的索引和切片">2.3 列表的索引和切片</h4>
<p>序列的切片操作完全一致，参见字符串</p>
<p>注意嵌套列表的元素获取</p>
<pre><code class="language-python">ls = [1,2,['a','b']]
ls[2][0]
</code></pre>
<p>'a'</p>
<h4 id="24-列表的常用操作">2.4 列表的常用操作</h4>
<p>python 中的列表操作非常灵活，是非常重要和经常使用的数据类型。</p>
<h5 id="241-修改元素">2.4.1 修改元素</h5>
<p>列表的中的元素可以进行修改，只需使用索引赋值即可。</p>
<pre><code class="language-python">ls = [1,2,3]
ls[1] = 'a'
print(ls)
</code></pre>
<p>[1, 'a', 3]</p>
<h5 id="242-增加元素">2.4.2 增加元素</h5>
<p>给列表添加元素需要使用到列表的方法</p>
<p><code>.append(el)</code>，在列表的末尾添加一个元素</p>
<pre><code class="language-python">ls = [1,2,3]
ls.append(4)
print(ls)
</code></pre>
<p>[1, 2, 3, 4]<br>
<code>.insert(index, el)</code>，在列表的指定索引处插入一个元素</p>
<pre><code class="language-python">ls = [1,2,3]
ls.insert(0,0)
print(ls)
</code></pre>
<p>[0, 1, 2, 3]<br>
<code>.extend(iterable)</code>，扩展列表，元素为传入的可迭代对象中的元素（不能传入数值）</p>
<pre><code class="language-python">ls = [1,2,3]
ls.extend([4,5,6])
print(ls)
</code></pre>
<p>[1, 2, 3, 4, 5, 6]</p>
<h5 id="243-删除元素">2.4.3 删除元素</h5>
<p><code>.pop(index=-1)</code>，删除指定索引的元素，并返回该元素，没有指定索引默认删除最后一个元素</p>
<pre><code class="language-python">ls = [1,2,3]
ls.pop()
</code></pre>
<p>3</p>
<pre><code class="language-python">  print(ls)
</code></pre>
<p>[1, 2]</p>
<pre><code class="language-python">  ls.pop(0)
</code></pre>
<p>1</p>
<pre><code class="language-python">print(ls)
</code></pre>
<p>[2]<br>
<code>.remove(value)</code>，从列表中删除第一个指定的值 value，如不存在 value 则报错。</p>
<pre><code class="language-python">ls = [1,2,3,1]
ls.remove(1)
print(ls)
</code></pre>
<p>[2, 3, 1]<br>
<code>.clear()</code>，清空列表，原列表变成空列表，等价于 del a[:]</p>
<pre><code class="language-python">ls = [1,2,3]
ls.clear()
print(ls)
</code></pre>
<p>[]</p>
<h4 id="25-列表的其他方法">2.5 列表的其他方法</h4>
<p><code>.copy()</code> 返回一个列表的浅拷贝。在讲可变与不可变类型的时候再详细讨论。</p>
<p><code>.count(value)</code>，统计列表中 value 的出现次数</p>
<pre><code class="language-python">ls = [1,2,3,1]
ls.count(1)
</code></pre>
<p>2<br>
<code>.index(value, start=0, stop=9223372036854775807)</code>，返回列表中指定值 value 的第一个索引，不存在则报错</p>
<pre><code class="language-python">ls = [1,2,3,1]
ls.index(1)
</code></pre>
<p>0</p>
<pre><code class="language-python">  l.index(1,1)
</code></pre>
<p>3<br>
<code>.reverse()</code>，翻转列表元素顺序</p>
<pre><code class="language-python">ls = [1,2,3]
ls.reverse()
print(ls)
</code></pre>
<p>[3, 2, 1]<br>
<code>.sort(key=None, reverse=False)</code>，对列表进行排序，默认按照从小到大的顺序，当参数 reverse=True 时，从大到小。注意列表中的元素类型需要相同，否则抛出异常。</p>
<pre><code class="language-python">ls = [2,1,3]
ls.sort()
print(ls)
</code></pre>
<p>[1, 2, 3]</p>
<pre><code class="language-python"># 从大到小
ls.sort(reverse=True) 
print(ls)
</code></pre>
<p>[3, 2, 1]</p>
<pre><code class="language-python">ls = [1,2,'3']
ls.sort()
</code></pre>
<hr>
<p>TypeError Traceback (most recent call last)</p>
<p>in<br>
1 ls = [1,2,'3']<br>
----&gt; 2 ls.sort()</p>
<p>TypeError: '&lt;' not supported between instances of 'str' and 'int'</p>
<h4 id="26-字符串和列表的转换">2.6 字符串和列表的转换</h4>
<p>字符串是字符组成的序列，可以通过 <code>list</code> 函数将字符串转换成单个字符的列表。</p>
<pre><code class="language-python">s = 'hello world!'
ls = list(s)
print(ls)
</code></pre>
<p>['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd', '!']<br>
由字符组成的列表可以通过字符串的 join 方法进行拼接</p>
<pre><code class="language-python"># 接上面的案例
''.join(ls)
</code></pre>
<p>'hello world!'</p>
<p><strong>join 方法</strong><br>
这个函数展开来写应该是str.join(item)，join函数是一个字符串操作函数</p>
<p>str表示字符串（字符），item表示一个成员，注意括号里必须只能有一个成员，比如','.join('a','b')这种写法是行不通的</p>
<p>举个例子：</p>
<pre><code class="language-python">','.join('abc')

</code></pre>
<p>上面代码的含义是“将字符串abc中的每个成员以字符','分隔开再拼接成一个字符串”，输出结果为：</p>
<pre><code class="language-python">'a,b,c'
</code></pre>
<p>join里放列表、元组、字典也是可以的</p>
<pre><code class="language-python">';'.join([a,b,c])
&gt;&gt;  'a;b;c'
</code></pre>
<h3 id="3-元组">3. 元组</h3>
<p>元组(tuple)表示任意元素的序列，元素可以是任意数据类型，序列中的元素不能增，删，改，可以说元组就是不可变的列表。</p>
<h4 id="31-元组的定义">3.1 元组的定义</h4>
<p>元组通过一对小括号进行定义，元组之间使用逗号隔开。</p>
<pre><code class="language-python">a = ()                      # 空元祖
b = (&quot;a&quot;, &quot;b&quot;, &quot;cde&quot;)       # 字符串
c = (1, &quot;b&quot;, &quot;c&quot;)           # 数字
d = (1, &quot;b&quot;, [])            # 列表
e = (1, &quot;b&quot;, (2, &quot;c&quot;))      # 元祖
f = 1,2

print('a的类型为：', type(a))    # a的类型为： &lt;class 'tuple'&gt;
print('b的类型为：', type(b))    # b的类型为： &lt;class 'tuple'&gt;
print('c的类型为：', type(c))    # c的类型为： &lt;class 'tuple'&gt;
print('d的类型为：', type(d))    # d的类型为： &lt;class 'tuple'&gt;
print('e的类型为：', type(e))    # e的类型为： &lt;class 'tuple'&gt;
print('f的类型为：', type(f))    # f的类型为： &lt;class 'tuple'&gt;
</code></pre>
<p>a 的类型为： &lt;class 'tuple'&gt;<br>
b 的类型为： &lt;class 'tuple'&gt;<br>
c 的类型为： &lt;class 'tuple'&gt;<br>
d 的类型为： &lt;class 'tuple'&gt;<br>
e 的类型为： &lt;class 'tuple'&gt;<br>
f 的类型为： &lt;class 'tuple'&gt;<br>
注意单元素元组的定义，一定要多加个逗号</p>
<pre><code class="language-python">g = ('hello')
h = ('hello',)
print('g的类型为：', type(g))    # g的类型为： &lt;class 'str'&gt;
print('h的类型为：', type(h))    # h的类型为： &lt;class 'tuple'&gt;
</code></pre>
<p>g 的类型为： &lt;class 'str'&gt;<br>
h 的类型为： &lt;class 'tuple'&gt;</p>
<h4 id="32-元组的索引和切片">3.2 元组的索引和切片</h4>
<p>序列的索引和切片完全一致，参加字符串。</p>
<h4 id="32-元组的常用操作">3.2 元组的常用操作</h4>
<p>元组的元素不能修改，增加和删除，其他操作和列表的操作一致。</p>
<p>元组利用不可修改的特性，应用在多变量赋值和函数多返回值上。</p>
<pre><code class="language-python">a, b = (1, 2)
# 经常简写为a, b= 1, 2
</code></pre>
<p>当然多变量赋值时可以使用可迭代对象，但是元组最安全，它是不可变的。</p>
<p>关于函数多返回值的问题我们后面再讲</p>
<h4 id="33-元组的常用方法">3.3 元组的常用方法</h4>
<p>元组只有两个公有方法 <code>count,index</code> 用法与列表相同。</p>
<h4 id="34-len-函数">3.4 len 函数</h4>
<p>python 内建函数 <code>len</code> 可以获取对象中包含的元素个数</p>
<pre><code class="language-python">s = 'hello'
ls = [1,2,3]
t = (1,2,3)
print(len(s))
print(len(ls))
print(len(t))
</code></pre>
<p>5<br>
3<br>
3</p>
<h3 id="4-可变与不可变对象">4. 可变与不可变对象</h3>
<ul>
<li>在 Python 中，一切皆为对象</li>
<li>Python 中不存在值传递，一切传递的都是对象的引用，也可以认为是传址</li>
</ul>
<h4 id="有哪些可变对象哪些不可变对象">有哪些可变对象，哪些不可变对象？</h4>
<ul>
<li>不可变对象：字符串、元组、数字（int、float）</li>
<li>可变对象：数组、字典、集合</li>
</ul>
<h4 id="不可变对象和可变对象的区别">不可变对象和可变对象的区别？</h4>
<ul>
<li>
<p>可变对象：改变对象内容，对象在内存中的地址不会被改变<br>
<img src="https://Shisuiyi.github.io/post-images/1634217079437.png" alt="" loading="lazy"><br>
变的是：原来对象的内容，不会创建新对象，而变量也还是指向原对象</p>
</li>
<li>
<p>不可变对象：改变对象内容，对象在内存中的地址会被改变；如果必须存储一个不同的值，则必须创建新的对象<br>
<img src="https://Shisuiyi.github.io/post-images/1634217054851.png" alt="" loading="lazy"></p>
</li>
<li>
<p>Python 中的变量有一个内存空间</p>
</li>
<li>
<p>具体的数据（对象）也有一个内存空间</p>
</li>
<li>
<p>而变量保存（指向）的是存储数据（对象）的内存地址，一般也叫对象引用</p>
</li>
<li>
<p>不可变对象是指对象内容本身不可变</p>
</li>
<li>
<p>变的是：改变了值，会创建新对象，然后变量改变了对象引用，指向了新对象，旧对象会被垃圾回收</p>
</li>
</ul>
<p>python 中的对象根据底层内存机制分为可变与不可变两种。<br>
可变对象可以在其 <code>id()</code> 保持固定的情况下改变其取值。<br>
下面的列表 a，修改值后，id 保持不变</p>
<pre><code class="language-python">a = [1,2,3]
id(a)
</code></pre>
<p>14053670614592</p>
<pre><code class="language-python"># 修改a的值
a[0] = 'a'
id(a)
# 修改a的值
a[0] = 'a'
id(a)
</code></pre>
<p>14053670614592</p>
<p>基本数据类型中列表，集合和字典都是可变数据类型。</p>
<p>如果修改一个对象的值，必须创建新的对象，那么这个对象就是不可变对象。</p>
<p>例如下面的字符串 s，修改内容后 id 发生了改变。</p>
<pre><code class="language-python">s = 'hello'
id(s)
</code></pre>
<p>3067776627760</p>
<pre><code class="language-python">s = 'Hello'
id(s)
</code></pre>
<p>3067782100656</p>
<p>基本数据类型中数字，字符串，元组是不可变对象。</p>
<h3 id="5可哈希对象">5.可哈希对象</h3>
<p>一个对象的哈希值如果在其生命周期内绝不改变，就被称为可哈希。可哈希对象都可以通过内置函数 <code>hash</code> 进行求值。</p>
<p>它们在需要常量哈希值的地方起着重要的作用，例如作为集合中的元素，字典中的键。</p>
<p>不可变数据类型都是可哈希对象，可变数据类型都是不可哈希对象。</p>
<pre><code class="language-python">  hash(1)
</code></pre>
<p>1</p>
<pre><code class="language-python">  hash([1,2])
</code></pre>
<hr>
<p>TypeError Traceback (most recent call last)</p>
<p>in<br>
----&gt; 1 hash([1,2])</p>
<p>TypeError: unhashable type: 'list'</p>
<h3 id="6赋值与深浅拷贝">6.赋值与深浅拷贝</h3>
<h4 id="61-赋值">6.1 赋值</h4>
<ul>
<li>变量：存储对象的引用</li>
<li>对象：会被分配一块内存，存储实际的数据，比如字符串、数字、列表</li>
<li>引用：变量指向对象，可以理解为指针</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://Shisuiyi.github.io/post-images/1634347489130.png" alt="" loading="lazy"></figure>
<p>python 是解释型编程语言，当解释器在碰到赋值语句时它首先会计算赋值符号右边的表达式的值，然后再创建左边的变量。</p>
<p>变量中实际存储的是值在内存中的地址，引用变量时通过地址指向内存中的值。通过内建函数 <code>id</code> 可以查看解释器中变量的虚拟内存地址整数值。</p>
<pre><code class="language-python">a = 1
id(a)
</code></pre>
<p>4382612480</p>
<p>python 的赋值语句不复制对象，而是创建目标和对象的绑定关系。<br>
所以将一个变量赋值给另外一个变量时，并不会创建新的值，只是新变量会指向值的内存地址</p>
<pre><code class="language-python">a = 1
b = a
id(a) == id(b)
</code></pre>
<p>True<br>
对于字符串和数字这样的不可变数据类型，当上例中的变量 a 自加 1 时，会创建一个新值重新，它不会改变原来的值。因此对变量 b 没有影响。</p>
<pre><code class="language-python">a += 1
print(a)
print(b)
</code></pre>
<p>2<br>
1<br>
但是看下面的案例</p>
<pre><code class="language-python">ls = [1,2,3]
ln = ls
ls[0] = 2
print(ls)
</code></pre>
<p>[2, 2, 3]<br>
会发现变量 ls 在修改列表的值后，变量 ln 的值也发生了同样的改变，这是因为 ls，ln 指向相同的列表。对可变数据类型进行变量赋值时要考虑这个特性。</p>
<h5 id="611-实际的一种应用场景">6.1.1 实际的一种应用场景</h5>
<ul>
<li>有一个变量 a，存储了一个值</li>
<li>此时想用另一个变量 b 暂时存储变量 a 的值，以便后续使用</li>
<li>然后继续修改变量 a 的值，但修改的时候并不想同步更改变量 b 的值</li>
</ul>
<pre><code class="language-python">a=1
b=a
a=2
</code></pre>
<ul>
<li>赋值运算符详解：https://www.cnblogs.com/poloyy/p/15083012.html</li>
<li>Python 的赋值语句并不是创建一个新对象，只是创建了一个共享原始对象引用的新变量</li>
</ul>
<p>不可变对象的赋值：</p>
<pre><code class="language-python">a = 1
b = a

print(a, b)

a += 2
print(a, b)

print(&quot;a id:&quot;, id(a))
print(&quot;b id:&quot;, id(b))


# 输出结果
1 1
2 1
a id: 4564097808
b id: 4564097776
</code></pre>
<ul>
<li>修改变量 a 的值，不会同步修改变量 b 的值</li>
<li>因为赋值操作 a += 2 后，变量 a 存储的对象引用已经改变了</li>
<li>至于具体的原理，可以看看不可变对象、可变对象的详解 https://www.cnblogs.com/poloyy/p/15073168.html</li>
</ul>
<p>可变对象的赋值：</p>
<pre><code class="language-python">a = [1, 2, 3]
b = a

print(a, b)

a[1] = 22
print(a, b)

print(&quot;a id:&quot;, id(a))
print(&quot;b id:&quot;, id(b))


# 输出结果
[1, 2, 3] [1, 2, 3]
[1, 22, 3] [1, 22, 3]
a id: 4567683136
b id: 4567683136
</code></pre>
<ul>
<li>修改 a 变量的值，会同步修改变量 b 的值，这不符合上面的说的实际应用场景</li>
<li>因为变量 a、b 指向的对象是可变对象，所以它们保存的对象引用都是一样的</li>
</ul>
<h5 id="612拷贝的诞生">6.1.2拷贝的诞生</h5>
<ul>
<li>那如果要让可变对象也能满足上述实际应用场景，要怎么做呢？</li>
<li>当然就是拷贝</li>
<li>而拷贝又分为浅拷贝、深拷贝，接下来会具体聊一聊两种拷贝的区别</li>
</ul>
<p>第一个重点总结</p>
<ul>
<li>对于不可变对象来说，赋值操作其实就可以满足上面说的实际应用场景</li>
<li>所以！后面要讲的浅拷贝、深拷贝对于不可变对象来说，和赋值操作是一样的效果！</li>
<li>记住！浅拷贝、深拷贝只针对可变对象，即列表、集合、字典！</li>
</ul>
<h5 id="613copy-模块">6.1.3copy 模块</h5>
<p>Python 提供了 copy 模块，包含了浅拷贝、深拷贝函数</p>
<pre><code class="language-python">from copy import copy, deepcopy

# 浅拷贝
copy(x)

# 深拷贝
deepcopy(x)
</code></pre>
<h4 id="62浅拷贝">6.2浅拷贝</h4>
<p>一句话概括：浅拷贝会创建一个新对象，该新对象存储原始元素的引用</p>
<h5 id="621浅拷贝后的值是相同的">6.2.1浅拷贝后的值是相同的</h5>
<ul>
<li>将列表赋值给变量 old_list</li>
<li>通过 copy() 方法对 old_list 变量指向的对象进行浅拷贝，并赋值给新变量 new_list</li>
<li>因为是对象进行拷贝，所以 new_list 和 old_list 存储的值是相同的</li>
</ul>
<pre><code class="language-python">import copy

old_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
new_list = copy.copy(old_list)

print(&quot;Old list:&quot;, old_list)
print(&quot;New list:&quot;, new_list)


# 输出结果
Old list: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
New list: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
</code></pre>
<h5 id="622浅拷贝后的会产生一个新的对象">6.2.2浅拷贝后的会产生一个新的对象</h5>
<ul>
<li>虽然 old_list 和 new_list 存储的值是相同的，但浅拷贝的操作是产生了一个新的对象</li>
<li>所以 old_list 和 new_list 指向的对象并不是同一个</li>
</ul>
<pre><code class="language-python">import copy

old_list = [[1, 2], [3, 4]]
new_list = copy.copy(old_list)

old_list.append([5, 6])

print(&quot;Old list:&quot;, old_list, &quot;id is :&quot;, id(old_list))
print(&quot;New list:&quot;, new_list, &quot;id is :&quot;, id(new_list))


# 输出结果
Old list: [[1, 2], [3, 4], [5, 6]] id is : 4366240704
New list: [[1, 2], [3, 4]] id is : 4366246720
</code></pre>
<p>可以看到内存地址是不同的，所以给 old_list 新增一个元素并不会同步让 new_list 也新增</p>
<p>原理图</p>
<figure data-type="image" tabindex="2"><img src="https://Shisuiyi.github.io/post-images/1634350406469.png" alt="" loading="lazy"></figure>
<ul>
<li>浅拷贝生成了一个新对象，然后赋值给 new_list</li>
<li>new_list、old_list 指向的列表对象不是同一个，但值相同</li>
<li>重点：对于列表对象中的元素，浅拷贝产生的新对象只存储原始元素的引用（内存地址），所以两个列表对象的元素的引用都指向同一个内存地址</li>
</ul>
<h5 id="623修改列表内的不可变对象元素">6.2.3修改列表内的不可变对象元素</h5>
<p>上面的栗子是直接添加元素，来看看修改元素会怎么样</p>
<pre><code class="language-python"># 不可变元素
import copy

old_list = [1, 2, &quot;string&quot;, (1, 2,)]
new_list = copy.copy(old_list)

old_list[1] += 22
old_list[2] += &quot;s&quot;
old_list[3] += (3,)

print(&quot;Old list:&quot;, old_list)
print(&quot;New list:&quot;, new_list)


# 输出结果
Old list: [1, 24, 'strings', (1, 2, 3)]
New list: [1, 2, 'string', (1, 2)]
</code></pre>
<p>修改 old_list 的三种不可变对象元素，均不会同步给 new_list</p>
<h5 id="624修改不可变对象的原理图">6.2.4修改不可变对象的原理图</h5>
<figure data-type="image" tabindex="3"><img src="https://Shisuiyi.github.io/post-images/1634350444560.png" alt="" loading="lazy"></figure>
<h5 id="625修改列表内的可变对象元素">6.2.5修改列表内的可变对象元素</h5>
<pre><code class="language-python"># 可变元素
import copy

old_list = [[1, 2], [3, 4]]
new_list = copy.copy(old_list)

old_list[0][0] += 99
old_list[1][0] += 97

print(&quot;Old list:&quot;, old_list, &quot;old list id:&quot;, id(old_list), &quot; old list[0] id:&quot;, id(old_list[0]))
print(&quot;new list:&quot;, new_list, &quot;new list id:&quot;, id(new_list), &quot; new list[0] id:&quot;, id(new_list[0]))


# 输出结果
Old list: [[100, 2], [100, 4]] old list id: 4430308096  old list[0] id: 4430302400
new list: [[100, 2], [100, 4]] new list id: 4430308416  new list[0] id: 4430302400
</code></pre>
<p>从输出结果看到</p>
<ul>
<li>两个变量保存了不同的对象引用</li>
<li>但是可变对象元素的内存地址仍然是同一个</li>
</ul>
<h5 id="626修改可变对象的原理图">6.2.6修改可变对象的原理图</h5>
<figure data-type="image" tabindex="4"><img src="https://Shisuiyi.github.io/post-images/1634350471733.png" alt="" loading="lazy"></figure>
<h5 id="627总结">6.2.7总结</h5>
<ul>
<li>修改可变对象是在原始对象上直接操作的</li>
<li>浅拷贝产生的新对象存储的仍然是原始对象的内存地址</li>
<li>所以修改可变对象的时候，新对象的值也会被同步修改，因为新旧列表对象的元素的引用是指向同一个内存地址</li>
<li>当修改可变对象的时候，不满足一开始说的实际应用场景，所以诞生了深拷贝</li>
</ul>
<h4 id="63-深拷贝">6.3 深拷贝</h4>
<ul>
<li>创建一个新对象，且存储的对象引用也是新的</li>
<li>深，意味着会把所有子元素对象也复制生成一个新对象</li>
</ul>
<p>栗子一</p>
<pre><code class="language-python"># 深拷贝
old_list = [[1, 2], [3, 4]]
new_list = copy.deepcopy(old_list)

old_list[0][0] += 99
old_list[1][0] += 97

print(&quot;Old list:&quot;, old_list, &quot;old list id:&quot;, id(old_list), &quot; old list[0] id:&quot;, id(old_list[0]))
print(&quot;new list:&quot;, new_list, &quot;new list id:&quot;, id(new_list), &quot; new list[0] id:&quot;, id(new_list[0]))


# 输出结果
Old list: [[100, 2], [100, 4]] old list id: 4430308480  old list[0] id: 4430211392
new list: [[1, 2], [3, 4]] new list id: 4430308096  new list[0] id: 4430308864
</code></pre>
<p>从输出结果看到</p>
<ul>
<li>两个变量保存了不同的对象引用</li>
<li>可变对象元素（子对象）的内存地址也是不同的</li>
</ul>
<p>栗子二</p>
<p>假设是一个三维列表呢</p>
<pre><code class="language-python"># 深拷贝-三维数组
old_list = [[1, [10, 9]], [3, 4]]
new_list = copy.deepcopy(old_list)

old_list[0][1][0] += 90

print(&quot;Old list:&quot;, old_list)
print(&quot;New list:&quot;, new_list)


# 输出结果
Old list: [[1, [100, 9]], [3, 4]]
New list: [[1, [10, 9]], [3, 4]]
</code></pre>
<p>两个变量依旧是独立的</p>
<h5 id="631深拷贝原理图">6.3.1深拷贝原理图</h5>
<figure data-type="image" tabindex="5"><img src="https://Shisuiyi.github.io/post-images/1634350504457.png" alt="" loading="lazy"></figure>
<h5 id="632浅拷贝的多种实现方式">6.3.2浅拷贝的多种实现方式</h5>
<p>https://www.cnblogs.com/poloyy/p/15086511.html</p>
<h5 id="633面试题浅拷贝-深拷贝的区别">6.3.3面试题：浅拷贝、深拷贝的区别</h5>
<ol>
<li>浅拷贝和深拷贝只有在可变对象才会生效，不可变对象的赋值操作、浅拷贝、深拷贝的效果是一样的</li>
<li>浅拷贝会将对象复制生成一个新对象，但新对象仍然存储原始对象的引用，当原始对象是可变对象，然后修改它的值时，新旧对象会同时改变</li>
<li>深拷贝不仅会将对象复制生成一个新对象，且所有原始对象都会复制生成新对象，即使原始对象是可变对象，新对象存储的对象引用也是新的，所以改变旧对象的可变对象时，不会影响新对象</li>
</ol>

        </div>

        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://Shisuiyi.github.io/oQOHcoQAu/">
            <span class="flex-auto">python</span>
          </a>
        


        <div class="flex justify-between py-8">
          
            <div class="prev-post">
              <a href="https://Shisuiyi.github.io/JdBD8Lzqe/">
                <h3 class="post-title">
                  <i class="ri-arrow-left-line"></i>
                  python基本数据类型 ·下
                </h3>
              </a>
            </div>
          

          
            <div class="next-post">
              <a href="https://Shisuiyi.github.io/w-B-uNoob/">
                <h3 class="post-title">
                   Python基本数据类型 ·上
                  <i class="ri-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '978584b9702b5d850dd5',
    clientSecret: 'b6647706cb7b990e2cd5ca77eccf73943df73a6c',
    repo: 'Shisuiyi.github.io',
    owner: 'shisuiyi',
    admin: ['shisuiyi'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

      </div>
    </div>

    <script src="https://Shisuiyi.github.io/media/prism.js"></script>  
<script>

Prism.highlightAll()
let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
